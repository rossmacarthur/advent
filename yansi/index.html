<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A dead simple ANSI terminal color painting library."><title>yansi - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-fa3bb1812debf86c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="yansi" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.0 (79e9716c9 2023-11-13)" data-channel="1.74.0" data-search-js="search-8be46b629f5f14a8.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-c5bd66d33317d69f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../yansi/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a></nav><nav class="sidebar"><a class="logo-container" href="../yansi/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate yansi</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 1.0.0-rc.1</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">yansi</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/yansi/lib.rs.html#1-365">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A dead simple ANSI terminal color painting library.</p>
<h2 id="features"><a href="#features">Features</a></h2>
<p>Why <em>y</em>et another <em>ANSI</em> terminal coloring library? Here are some reasons:</p>
<ul>
<li>This library makes simple things <em>simple</em>: <code>use</code> <a href="trait.Paint.html" title="trait yansi::Paint"><code>Paint</code></a> and go!</li>
<li>Zero dependencies by default. It really is simple.</li>
<li>Zero allocations except as needed by opt-in <a href="#wrapping">wrapping</a>.</li>
<li><a href="#windows">Automatic Windows support</a> for the vast majority (95%+) of Windows
users.</li>
<li><a href="#crate-features">Featureful <code>no_std</code></a>, no-<code>alloc</code>, support with <code>default-features = false</code>.</li>
<li><a href="#uniform-const-builders"><code>Style</code> constructors are <code>const</code></a>: store styles statically, even with
dynamic conditions!</li>
<li><em>Any</em> type implementing a formatting trait can be styled, not just
strings.</li>
<li>Styling can be <a href="fn.enable.html" title="fn yansi::enable">enabled</a> and <a href="fn.disable.html" title="fn yansi::disable">disabled</a> globally and <a href="fn.whenever.html" title="fn yansi::whenever">dynamically</a>, on
the fly.</li>
<li>A <code>Style</code> can be predicated on arbitrary <a href="#per-style">conditions</a>.</li>
<li>Formatting specifiers like <code>{:x}</code> and <code>{:08b}</code> are supported and
preserved!</li>
<li><a href="struct.Condition.html#built-in-conditions" title="struct yansi::Condition">Built-in (optional) conditions</a> for <a href="struct.Condition.html#impl-Condition-1" title="struct yansi::Condition">TTY detection</a> and <a href="struct.Condition.html#impl-Condition-2" title="struct yansi::Condition">common
environment variables</a>.</li>
<li>Arbitrary items can be <a href="#masking"><em>masked</em></a> for selective disabling.</li>
<li>Styling can <a href="#wrapping"><em>wrap</em></a> to preserve styling across resets.</li>
<li>Styling can <a href="#lingering"><em>linger</em></a> beyond a single value.</li>
<li>Experimental support for <a href="hyperlink">hyperlinking</a> is included.</li>
<li>The name <code>yansi</code> is pretty cool 😎.</li>
</ul>
<p>All that said, <code>yansi</code> borrows API ideas from older libraries as well as
implementation details from <a href="https://crates.io/crates/ansi_term"><code>ansi_term</code></a>.</p>
<h2 id="usage"><a href="#usage">Usage</a></h2>
<p>The <a href="trait.Paint.html" title="trait yansi::Paint"><code>Paint</code></a> trait is implemented for every type. Import it and call
chainable builder methods:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

<span class="macro">println!</span>(<span class="string">&quot;Testing, {}, {}, {}!&quot;</span>,
    <span class="string">&quot;Ready&quot;</span>.bold(),
    <span class="string">&quot;Set&quot;</span>.yellow().italic(),
    <span class="string">&quot;STOP&quot;</span>.white().on_red().bright().underline().bold());</code></pre></div>
<p><code>&gt;</code> Testing,
<b>Ready</b>,
<span style="color: yellow;"><i><b>Set</b></i></span>,
<span style="color: white; background: red;"><u><b>STOP</b></u></span>!</p>
<p>The methods return a <a href="struct.Painted.html" title="struct yansi::Painted"><code>Painted</code></a> type which consists of a <a href="struct.Style.html" title="struct yansi::Style"><code>Style</code></a> and a
reference to the receiver. Displaying a <a href="struct.Painted.html" title="struct yansi::Painted"><code>Painted</code></a> (via <code>print!()</code>,
<code>format!()</code>, etc) results in emitting ANSI escape codes that effectuate the
style.</p>
<h3 id="uniform-const-builders"><a href="#uniform-const-builders">Uniform <code>const</code> Builders</a></h3>
<p>The builder methods are uniformly available for <a href="struct.Style.html" title="struct yansi::Style"><code>Style</code></a>, <a href="enum.Color.html" title="enum yansi::Color"><code>Color</code></a>, and
<a href="struct.Painted.html" title="struct yansi::Painted"><code>Painted</code></a>, which means you can chain calls across library types. They are
also <code>const</code>, allowing creations of <code>const</code> or <code>static</code> styles which can be
directly applied via the <a href="trait.Paint.html#method.paint" title="method yansi::Paint::paint"><code>paint()</code></a> method, also from the
<a href="trait.Paint.html" title="trait yansi::Paint"><code>Paint</code></a> trait and thus available for every type:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Style, Color::<span class="kw-2">*</span>};

<span class="comment">// `const` constructors allow static `Style` for easy reuse.
</span><span class="kw">static </span>ALERT: Style = White.bright().underline().italic().on_red();

<span class="macro">println!</span>(<span class="string">&quot;Testing, {}, {}, {}!&quot;</span>,
    <span class="string">&quot;Ready&quot;</span>.bold(),
    <span class="string">&quot;Set&quot;</span>.yellow().bold(),
    <span class="string">&quot;STOP&quot;</span>.paint(ALERT));</code></pre></div>
<p><code>&gt;</code> Testing,
<b>Ready</b>,
<span style="color: yellow;"><b>Set</b></span>,
<span style="color: white; background: red;"><u><em>STOP</em></u></span>!</p>
<h3 id="conditional-styling"><a href="#conditional-styling">Conditional Styling</a></h3><h4 id="globally"><a href="#globally">Globally</a></h4>
<p>Styling is enabled by default but can be enabled and disabled globally via
<a href="fn.enable.html" title="fn yansi::enable"><code>enable()</code></a> and <a href="fn.disable.html" title="fn yansi::disable"><code>disable()</code></a>. When styling is disabled, no ANSI escape
codes are emitted, and <a href="#masking"><em>masked</em></a> values are omitted.</p>
<p>Stying can also be globally enabled <em>conditionally</em> and dynamically  via
<a href="fn.whenever.html" title="fn yansi::whenever"><code>whenever()</code></a> based on an arbitrary <a href="struct.Condition.html" title="struct yansi::Condition"><code>Condition</code></a>: a function that returns
<code>true</code> to enable styling and <code>false</code> to disable it. The condition is
evaluated every time a <a href="struct.Painted.html" title="struct yansi::Painted"><code>Painted</code></a> items is displayed.</p>
<h4 id="per-style"><a href="#per-style">Per-<code>Style</code></a></h4>
<p>A specific <code>Style</code> can also itself be conditionally applied by using
<a href="struct.Style.html#method.whenever" title="method yansi::Style::whenever"><code>whenever()</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::{Paint, Style, Color::<span class="kw-2">*</span>, Condition};

<span class="kw">static </span>WARNING: Style = Black.bold().on_yellow().whenever(Condition::STDERR_IS_TTY);

<span class="macro">eprintln!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;Bees can sting!&quot;</span>.paint(WARNING));</code></pre></div>
<p>With the above, if <code>stderr</code> is a TTY, then:
<code>&gt;</code> <span style="background: yellow; color: black;"><b>Bees can sting!</b></span></p>
<p>If it is not a TTY, styling is not emitted:
<code>&gt;</code> Bees can sting!</p>
<p>See <a href="struct.Condition.html" title="struct yansi::Condition"><code>Condition</code></a> for a list of built-in conditions which require enabling
crate features.</p>
<h2 id="quirks"><a href="#quirks">Quirks</a></h2>
<p><code>yansi</code> implements several “quirks”, applicable via <a href="enum.Quirk.html" title="enum yansi::Quirk"><code>Quirk</code></a> and the
respective methods, that modify if and how styling is presented to the
terminal. These quirks do not correspond to any ANSI styling sequences.</p>
<h3 id="masking"><a href="#masking">Masking</a></h3>
<p>Items can be arbitrarily <em>masked</em> with the <a href="trait.Paint.html#tymethod.mask" title="method yansi::Paint::mask"><code>mask()</code></a> builder
method. Masked values are not emitted when styling is disabled, globally or
for a given style. This allows selective output based on whether styling is
enabled.</p>
<p>One use for this feature is to print certain characters only when styling is
enabled. For instance, you might wish to emit the 🎨 emoji when coloring is
enabled but not otherwise. This can be accomplished by masking the emoji:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

<span class="macro">println!</span>(<span class="string">&quot;I like colors!{}&quot;</span>, <span class="string">&quot; 🎨&quot;</span>.mask());</code></pre></div>
<p>When styling is enabled, this prints: <code>&gt;</code> I like colors! 🎨</p>
<p>With styling disabled, this prints: <code>&gt;</code> I like colors!</p>
<h3 id="wrapping"><a href="#wrapping">Wrapping</a></h3>
<p><strong>Note:</strong> <em>Either the <code>std</code> or <code>alloc</code> feature is required for wrapping.
<code>std</code> is enabled by default. See <a href="#crate-features">crate features</a>.</em></p>
<p>Styling can <em>wrap</em> via <a href="enum.Quirk.html#variant.Wrap" title="variant yansi::Quirk::Wrap"><code>Quirk::Wrap</code></a> or the equivalent
<a href="struct.Painted.html#method.wrap" title="method yansi::Painted::wrap"><code>wrap()</code></a> constructor. A wrapping style modifies any
styling resets emitted by the internal value so that they correspond to the
wrapping style. In other words, the “reset” style of the wrapped item is
modified to be the wrapping style.</p>
<p>It is needed only in situations when styling opaque items or items that may
already be styled, such as when implementing a generic logger. It exists to
enable consistent styling across such items:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

<span class="comment">// Imagine that `inner` is opaque and we don&#39;t know it&#39;s styling.
</span><span class="kw">let </span>inner = <span class="macro">format!</span>(<span class="string">&quot;{} and {}&quot;</span>, <span class="string">&quot;Stop&quot;</span>.red(), <span class="string">&quot;Go&quot;</span>.green());

<span class="comment">// We can use `wrap` to ensure anything in `inner` not styled is blue.
</span><span class="macro">println!</span>(<span class="string">&quot;Hey! {}&quot;</span>, inner.blue().wrap());</code></pre></div>
<p>Thanks to wrapping, this prints:
<code>&gt;</code> Hey! <span style="color: blue">
<span style="color: red">Stop</span> and
<span style="color: green">Go</span>
</span></p>
<p>Without wrapping, the <code>red()</code> reset after “Stop” is not overwritten:
<code>&gt;</code> Hey! <span style="color: red">Stop</span> and <span style="color: green">Go</span></p>
<p>Wrapping incurs a performance cost via an extra allocation and replacement
if the wrapped item has styling applied to it. Otherwise, it does not
allocate nor incur a meaningful performance cost.</p>
<h3 id="lingering"><a href="#lingering">Lingering</a></h3>
<p>Styling can <em>linger</em> beyond a single value via <a href="enum.Quirk.html#variant.Linger" title="variant yansi::Quirk::Linger"><code>Quirk::Linger</code></a> or the
equivalent <a href="struct.Painted.html#method.linger" title="method yansi::Painted::linger"><code>linger()</code></a> constructor. A lingering style
does not clear itself after being applied. In other words, the style lingers
on beyond the value it’s applied to and until something else clears the
respective styling.</p>
<p>The complement to lingering is force clearing via <a href="enum.Quirk.html#variant.Clear" title="variant yansi::Quirk::Clear"><code>Quirk::Clear</code></a> or the
equivalent <a href="struct.Painted.html#method.clear" title="method yansi::Painted::clear"><code>clear()</code></a> constructor. Force clearing, as the
name implies, forces a clear suffix to be emitted after the value,
irrespective of any lingering applied. It can be used as a way to finalize a
lingering style.</p>
<p>Lingering itself is useful in situations where a given style is to be
repeated across multiple values, or when style is intended to persist even
across values that are not styled with <code>yansi</code>. It also allows avoiding
unnecessarily repeated ANSI code sequences. The examples below illustrate
some scenarios in which lingering is useful:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

<span class="macro">println!</span>(<span class="string">&quot;Hello! {} {} things with {} {}?&quot;</span>,
    <span class="string">&quot;How&quot;</span>.magenta().underline().linger(),
    <span class="string">&quot;are&quot;</span>.italic().linger(),
    <span class="string">&quot;you&quot;</span>.on_yellow(), <span class="comment">// doesn&#39;t linger, so all styling is cleared here
    </span><span class="string">&quot;today&quot;</span>.blue());</code></pre></div>
<p><code>&gt;</code> Hello!
<span style="color: magenta;">
<u>How <i>are things with <span style="background: yellow;">you</span></i></u>
</span>
<span style="color: blue;">today</span>?</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

<span class="macro">println!</span>(<span class="string">&quot;Hello! {} {} things with {} {}?&quot;</span>,
    <span class="string">&quot;How&quot;</span>.magenta().underline().linger(),
    <span class="string">&quot;are&quot;</span>.italic(), <span class="comment">// doesn&#39;t linger, so all styling is cleared here
    </span><span class="string">&quot;you&quot;</span>.on_yellow().linger(),
    <span class="string">&quot;today&quot;</span>.blue()); <span class="comment">// doesn&#39;t linger; styling is cleared</span></code></pre></div>
<p><code>&gt;</code> Hello!
<span style="color: magenta;">
<u>How <i>are</i></u>
</span>
things with
<span style="background: yellow;">
you
<span style="color: blue;">today</span></span>?</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

<span class="macro">println!</span>(<span class="string">&quot;{} B {} {} {} F&quot;</span>,
    <span class="string">&quot;A&quot;</span>.red().linger(),
    <span class="string">&quot;C&quot;</span>.underline().linger(),
    <span class="string">&quot;D&quot;</span>, <span class="comment">// doesn&#39;t linger, but no styling applied, thus no clear
    </span><span class="string">&quot;E&quot;</span>.clear());  <span class="comment">// explicitly clear</span></code></pre></div>
<p><code>&gt;</code> <span style="color: red;"> A B <u>C D E</u> </span> F</p>
<h3 id="brightening"><a href="#brightening">Brightening</a></h3>
<p>Most pimrary colors are available in regular and <em>bright</em> variants, e.g.,
<a href="enum.Color.html#variant.Red" title="variant yansi::Color::Red"><code>Color::Red</code></a> and <a href="enum.Color.html#variant.BrightRed" title="variant yansi::Color::BrightRed"><code>Color::BrightRed</code></a>. The <a href="enum.Quirk.html#variant.Bright" title="variant yansi::Quirk::Bright"><code>Quirk::Bright</code></a> and
<a href="enum.Quirk.html#variant.OnBright" title="variant yansi::Quirk::OnBright"><code>Quirk::OnBright</code></a> quirks, typically applied via
<a href="struct.Painted.html#method.bright" title="method yansi::Painted::bright"><code>bright()</code></a> and <a href="struct.Painted.html#method.on_bright" title="method yansi::Painted::on_bright"><code>on_bright()</code></a>,
provide an alternative, convenient mechanism to select the bright variant of
the selected foreground or background color, respectively. The quirk
provides no additional colors and is equivalent to selecting the bright
variants directly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>yansi::Paint;

<span class="comment">// These are all equivalent.
</span><span class="macro">print!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;Regular&quot;</span>.red());
<span class="macro">print!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;Bright&quot;</span>.bright_red());
<span class="macro">print!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;Bright&quot;</span>.bright().red());
<span class="macro">print!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;Bright&quot;</span>.red().bright());

<span class="comment">// The `bright` quirk lets use choose the bright variants of _any_ color,
// even when the color or style is unknown at the call site.
</span><span class="macro">print!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;Normal&quot;</span>.paint(STYLE));
<span class="macro">print!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;Bright&quot;</span>.paint(STYLE).bright());</code></pre></div>
<p><code>&gt;</code> <span style="color: red;">Regular</span>
<span style="color: hotpink;">Bright</span>
<span style="color: hotpink;">Bright</span>
<span style="color: hotpink;">Bright</span>
<span style="color: green;"><b>Normal</b></span>
<span style="color: greenyellow;"><b>Bright</b></span></p>
<p>The <code>bright()</code> quirk can be applied before or after a color is selected
while having the same effect.</p>
<h2 id="windows"><a href="#windows">Windows</a></h2>
<p>Styling is supported and enabled automatically on Windows beginning with
the Windows 10 Anniversary Update, or about <a href="https://gs.statcounter.com/os-version-market-share/windows/desktop/worldwide">95% of all Windows machines
worldwide</a>,
and likely closer to 100% of developer machines (e.g., 99% of visitors to
<a href="https://rocket.rs">rocket.rs</a> on Windows are on Windows 10+).</p>
<p>Yansi enables styling support on Windows by querying the Windows API on the
first attempt to color. If support is available, it is enabled. If support
is not available, styling is disabled and no styling is emitted.</p>
<h2 id="crate-features"><a href="#crate-features">Crate Features</a></h2><div><table><thead><tr><th>Feature</th><th>Default?</th><th>Also Enables</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>std</code></td><td><strong>Y</strong></td><td><code>alloc</code></td><td>Use <code>std</code> library.</td></tr>
<tr><td><code>alloc</code></td><td><strong>Y</strong></td><td></td><td>Use <code>alloc</code>. Enables <a href="#wrapping">wrapping</a>.</td></tr>
<tr><td><code>detect-tty</code></td><td>N</td><td><code>std</code></td><td>See <a href="struct.Condition.html#built-in-conditions" title="struct yansi::Condition">optional conditions</a>.</td></tr>
<tr><td><code>detect-env</code></td><td>N</td><td><code>std</code></td><td>See <a href="struct.Condition.html#built-in-conditions" title="struct yansi::Condition">optional conditions</a>.</td></tr>
<tr><td><code>hyperlink</code></td><td>N</td><td><code>std</code></td><td>Enables <a href="hyperlink">hyperlinking</a> support.</td></tr>
</tbody></table>
</div>
<p>With <code>no-default-features = true</code>, this crate is <code>#[no_std]</code>.</p>
<p>Without any features enabled, all functionality except <a href="#wrapping">wrapping</a> is
available. To recover wrapping <em>with</em> <code>#[no_std]</code>, set <code>no-default-features = false</code> and enable the <code>alloc</code> feature, which requires <code>alloc</code> support.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Condition.html" title="struct yansi::Condition">Condition</a></div><div class="desc docblock-short">A function that decides whether styling should be applied.</div></li><li><div class="item-name"><a class="struct" href="struct.Painted.html" title="struct yansi::Painted">Painted</a></div><div class="desc docblock-short">An arbitrary value with a <a href="struct.Style.html" title="struct yansi::Style"><code>Style</code></a> applied to it.</div></li><li><div class="item-name"><a class="struct" href="struct.Style.html" title="struct yansi::Style">Style</a></div><div class="desc docblock-short">A set of styling options.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Attribute.html" title="enum yansi::Attribute">Attribute</a></div><div class="desc docblock-short">Enum representing text attributes, largely for text formatting.</div></li><li><div class="item-name"><a class="enum" href="enum.Color.html" title="enum yansi::Color">Color</a></div><div class="desc docblock-short">Enum representing a terminal color.</div></li><li><div class="item-name"><a class="enum" href="enum.Quirk.html" title="enum yansi::Quirk">Quirk</a></div><div class="desc docblock-short">Enum representing a <code>yansi</code> quirk.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Paint.html" title="trait yansi::Paint">Paint</a></div><div class="desc docblock-short">A trait to apply styling to any value, implemented for all types.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.disable.html" title="fn yansi::disable">disable</a></div><div class="desc docblock-short">Unconditionally disables styling globally.</div></li><li><div class="item-name"><a class="fn" href="fn.enable.html" title="fn yansi::enable">enable</a></div><div class="desc docblock-short">Unconditionally enables styling globally.</div></li><li><div class="item-name"><a class="fn" href="fn.is_enabled.html" title="fn yansi::is_enabled">is_enabled</a></div><div class="desc docblock-short">Returns <code>true</code> if styling is globally enabled and <code>false</code> otherwise.</div></li><li><div class="item-name"><a class="fn" href="fn.whenever.html" title="fn yansi::whenever">whenever</a></div><div class="desc docblock-short">Dynamically enables styling globally based on <code>condition</code>.</div></li></ul></section></div></main></body></html>